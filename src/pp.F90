!+---------------------------------------------------------------------+
!| This module contains subroutines for pre and post-process           |
!+---------------------------------------------------------------------+
!| ==============                                                      |
!| CHANGE RECORD                                                       |
!| -------------                                                       |
!|  28-05-2021  | Created by J. Fang @ Warrington                      |
!+---------------------------------------------------------------------+
module pp
  !
  use constdef
  use stlaio,  only: get_unit
  !
  implicit none
  !
  contains
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is the entrance of post/pre-process.              |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine ppentrance
    !
    use cmdefne
    use readwrite,       only : readinput
    use gridgeneration,  only : gridgen
    use solver,          only : refcal
    !
    ! local data
    character(len=64) :: cmd,casefolder,inputfile,outputfile,viewmode, &
                         flowfieldfile
    !
    call readkeyboad(cmd)
    print*,' ** pp command: ',cmd
    !
    if(trim(cmd)=='init') then
      !
      call readkeyboad(casefolder)
      call examplegen(trim(casefolder))
      ! generate an example channel flow case
      !
    elseif(trim(cmd)=='gridgen') then
      call readinput
      !
      call gridgen
    elseif(trim(cmd)=='divfree') then
      call readinput
      !
      call div_free_gen
    elseif(trim(cmd)=='solid') then
      call solidpp
      !
    elseif(trim(cmd)=='lamprof') then
      !
      call readinput
      !
      call refcal
      !
      call lamprof
      !
    elseif(trim(cmd)=='datacon') then
      !
      call readkeyboad(inputfile)
      !
      if(trim(inputfile)=='all') then
        call stream2struc('outdat/flowfield')
        call stream2struc('outdat/meanflow')
        call stream2struc('outdat/2ndsta')
        call stream2struc('outdat/3rdsta')
        call stream2struc('outdat/budget')
      else
        call stream2struc(trim(inputfile))
      endif
      !
    elseif(trim(cmd)=='parinfo') then
      !
      call parallelifogen
      !
    elseif(trim(cmd)=='view') then
      !
      call readkeyboad(flowfieldfile)
      call readkeyboad(outputfile)
      call readkeyboad(viewmode)
      call readkeyboad(inputfile)
      !
      call fieldview(trim(flowfieldfile),trim(outputfile),trim(viewmode),trim(inputfile))
      !
    else
      stop ' !! pp command not defined. @ ppentrance'
    endif
    ! 
    !
  end subroutine ppentrance
  !+-------------------------------------------------------------------+
  !| The end of the subroutine preprocess.                             |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a laminar boundary layer profile.  |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 19-04-2023  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine lamprof
    !
    use cmdefne,   only : readkeyboad
    use commvar,   only : gridfile,im,jm,km,ia,ja,ka,Mach,Reynolds
    use bc,        only : twall
    use readwrite, only : readgrid
    use commarray, only : x
    use str2real_m
    !
    ! local data
    integer :: j,j0
    real(8) :: red
    character(len=16) :: cnumb
    real(8),allocatable :: u(:),v(:),t(:),ro(:),y(:)
    !
    call readkeyboad(cnumb)
    !
    red=str2real(trim(cnumb))
    print*,' ** target Reynolds number is:',red
    !
    im=ia
    jm=ja
    km=ka
    !
    allocate(u(0:jm),v(0:jm),t(0:jm),ro(0:jm),y(0:jm))
    !
    call readgrid(trim(gridfile))
    !
    y(:)=x(0,0:jm,0,2)
    !
    do j=0,jm
      !
      if(x(0,j,0,2)>=0.d0) then
        j0=j
        exit
      endif
      !
    enddo
    write(*,'(A,I0,A,F10.5)')'  ** the wall boundary located at j=',j0,', y=',x(0,j0,0,2)
    !
    call laminar_boundary_layer_solution(      ma=  Mach,      &
                                               re=  Reynolds,  &
                                               tw=  twall(3),  &
                                         retarget=  red,       &
                                                y=  y,         &
                                               u1=  u,         &
                                               u2=  v,         &
                                              tmp=  t )
    !
  end subroutine lamprof
  !+-------------------------------------------------------------------+
  !| The end of the subroutine lamprof.                                |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is a laminar boundaryer solution.                 |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 19-04-2023  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine laminar_boundary_layer_solution(ma,re,tw,retarget,y,u1,u2,tmp)
    !
    use commvar,   only : prandtl,gamma,const2,const5,pinf
    use fludyna,   only : miucal
    use interp,    only : regularlinearinterp1d1v
    !
    real(8),intent(in) :: ma,re,tw,retarget
    real(8),intent(in) :: y(:)
    real(8),intent(out),allocatable :: u1(:),u2(:),tmp(:)
    !
    ! local data
    integer :: jmax
    real(8),allocatable,dimension(:) :: ye,y2,f,f1,f2,f3,t,t1,t2,u,v,ro
    real(8) :: tadi,dye,pre,den,thick1,thick2,thick3,miu
    !
    integer :: n,j,j1,i
    real(8) :: xin,erru,errt,df2,dt,f210,f211,t00,t01,var0,var1,var2
    !
    logical :: lcalcu=.true.
    !
    tadi=1.d0+0.5d0*const5*sqrt(prandtl)
    !
    ! print*,' **     wall temperature=',tw
    ! print*,' ** adibatic temperature=',tadi
    !
    jmax=256
    !
    allocate( ye(0:jmax),y2(0:jmax),f(0:jmax),f1(0:jmax),f2(0:jmax),f3(0:jmax), &
              t(0:jmax),t1(0:jmax),t2(0:jmax),u(0:jmax),v(0:jmax),ro(0:jmax)    )
    !
    do j=0,jmax
      ye(j)=20.d0/jmax*j
    end do
    dye=ye(1)-ye(0)
    !
    ! initial guess a x location, and change it according the Reynolds number
    xin=20.d0
    !
    do while(lcalcu)
      !
      !
      ! Initial Boundary value
      f(0)=0.d0
      f1(0)=0.d0
      !
      ! shooting
      f2(0)=0.33206d0 
      !
      f3(0)=-1.d0*f(0)*f2(0)
      !
      !
      ! shooting
      t(0)=tw
      !
      t(jmax)=1.d0
      ! print*,' ** Twall=',t(0)
      !
      den=pinf/t(0)*const2
      miu=MiuCal(t(0))
      !
      ! adiabatic wall
      t1(0)= 1.d0
      t2(0)=-const5*den*miu*f2(0)**2-f(0)*t1(0)
      !
      
      
      erru=1.d0  ; errt=1.d0
      df2=0.01d0 ; dt=0.01d0
      n=0
      !
      do while(errt>1.d-6 .and. erru>1.d-6)
        !
        n=n+1
        !
        erru=0.d0; errt=0.d0
        !
        f210=f1(jmax)-1.d0
        t00 =t(jmax)-1.d0
        !
        call blasius_solution(f,f1,f2,f3,t,t1,t2,dye)
        !
        ! shooting f2(0) to satisify f1(jmax)=1.d0
        erru=max(erru,dabs(f1(jmax)-1.d0))
        !
        f211=f1(jmax)-1.d0
        !
        if(f210*f211>0.d0) then
        else
          df2=df2*0.25d0
        end if
        !
        if(f1(jmax)<1.d0) then
          f2(0)=f2(0)+df2
        elseif(f1(jmax)>1.d0) then
          f2(0)=f2(0)-df2
        end if
        !
        ! shooting t1(0) to satisify t(jmax)=1.d0
        errt=max(errt,dabs(t(jmax)-1.d0))
        t01=t(jmax)-1.d0
        if(t00*t01>0.d0) then
        else
          dt=dt*0.5d0
        end if
        !
        if(t(jmax)<1.d0) then
          t1(0)=t1(0)+dt
        elseif(t(jmax)>1.d0) then
          t1(0)=t1(0)-dt
        end if
        !
        ! print*,n,errt,t1(0),t(jmax),dt
        !
      end do
      print*,' ** solution converged at errors:',erru,errt
      !
      var0=1.d0/sqrt(2.d0*xin*re)
      do j=0,jmax
        u(j)=f1(j)
        v(j)=0.d0
        do i=1,j
          var1=0.5d0*(t(i)+t(i-1))*dye
          var2=0.5d0*(u(i)+u(i-1))*dye
          v(j)=v(j)+var0*(u(j)*var1-t(j)*var2)
        end do
      end do
      !
      y2(0)=0.d0
      var1=sqrt(2.d0*xin/re)
      do j=1,jmax
        y2(j)=0.d0
        do i=1,j
          y2(j)=y2(j)+var1*0.5d0*(t(i)+t(i-1))*dye
        end do
      end do
      !
      ! Calculationg of boundary thickness
      thick1=0.d0
      thick2=0.d0
      thick3=0.d0
      !
      var0=u(jmax)*0.99d0
      do j=1,jmax
        if(u(j-1)<=var0 .and. u(j)>=var0) then
          thick1=(y2(j)-y2(j-1))/(u(j)-u(j-1))*(var0-u(j-1))+y2(j-1)
          j1=j
          exit
        end if
      end do
      
      ro=1.d0/t
      
      var0=ro(jmax)*u(jmax)
      do j=1,jmax
        var1=0.5d0*(ro(j)+ro(j-1))
        var2=0.5d0*(u(j)+u(j-1))
        thick2=thick2+(1.d0-var1*var2/var0)*(y2(j)-y2(j-1))
      end do
      !
      var0=ro(jmax)*u(jmax)**2
      do j=1,jmax
        var1=0.5d0*(ro(j)+ro(j-1))
        var2=0.5d0*(u(j)+u(j-1))
        thick3=thick3+(var1*var2*(u(jmax)-var2))/var0*(y2(j)-y2(j-1))
      end do
      !
      ! print*,'norminal thickness=',thick1
      ! print*,'displacement thickness=',thick2
      ! print*,'momentum thickness=',thick3
      ! !
      ! print*,'Reynolds Based on x=',re*xin
      ! print*,'Reynolds Based on δ=',re*thick1
      ! print*,'Reynolds Based on δ*=',re*thick2
      ! print*,'Reynolds Based on θ=',re*thick3
      !
      write(*,'(3(A,F10.5))')'  ** Reδ=',re*thick1,'at x=',xin,' -- target Reδ=',retarget
      !
      if(abs(retarget-re*thick1)/retarget<0.05d0) then
        lcalcu=.false.
      else
        xin=xin*retarget/(re*thick1)
      endif
      !
    enddo
    !
    deallocate(ro)
    !
    allocate(u1(1:size(y)),u2(1:size(y)),tmp(1:size(y)),ro(1:size(y)))
    !
    call regularlinearinterp1d1v(y2,u,y,u1)
    call regularlinearinterp1d1v(y2,v,y,u2)
    call regularlinearinterp1d1v(y2,t,y,tmp)
    !
    ro=1.d0/tmp
    !
    open(16,file='inlet.prof')    
    write(16,"(A26)")'# parameters of inlet flow'
    write(16,"(4(1X,A14))")'delta','delta*','theter','utaw'
    write(16,"(4(1X,E14.7E2))")thick1,thick2,thick3,0.d0
    write(16,"(4(1X,A14))")'ro','u1','u2','t'
    write(16,"(4(1X,E14.7E2))")(ro(j),u1(j),u2(j),tmp(j),j=1,size(y))
    close(16)
    print*,' <<< inlet.prof ... done!'
    !
    open(18,file='inlet.dat')
    write(18,"(5(1X,A15))")'y','ro','u','v','T'
    do j=1,size(y)
      write(18,"(5(1X,E15.7E3))")y(j),ro(j),u1(j),u2(j),tmp(j)
    end do
    close(18)
    print*,' << inlet.dat ... done.'
    !
    ! do j=1,size(y)
    !   print*,j,y(j),u1(j),u2(j),tmp(j)
    ! enddo
    !
    ! !
    ! open(18,file='CompBlasius.dat')
    ! write(18,"(5(1X,A15))")'y','yn','u','v','t'
    ! do j=0,jmax
    !   write(18,"(5(1X,E15.7E3))")y2(j),y2(j)*sqrt(re/xin),u(j),v(j),t(j)
    ! end do
    ! close(18)
    ! print*,' << CompBlasius.dat'
    ! !
    ! print*,'Reynolds ',re
    !
  end subroutine laminar_boundary_layer_solution
  !+-------------------------------------------------------------------+
  !| The end of the subroutine laminar_boundary_layer_solution.        |
  !+-------------------------------------------------------------------+
  !
  subroutine blasius_solution(f,f1,f2,f3,t,t1,t2,dy)
    !
    use commvar,   only : prandtl,const2,const5,pinf
    use fludyna,   only : miucal
    !
    real(8),intent(inout),dimension(:) ::  f,f1,f2,f3,t,t1,t2
    real(8),intent(in) ::  dy
    !
    ! local data
    integer :: jdim,j,n
    real(8) :: err,var0,var1,var2,var3,var4,var5,var6,miu,den,rom,rom2,p0,p1,p2,p3,q0,q1,q2
    !
    jdim=size(f)
    !
    err=1.d0
    n=0
    do while(err>1d-6)
      !
      n=n+1
      err=0.d0
      !
      do j=2,jdim
        !
        ! predictor
        miu=miucal(t(j-1))
        den=pinf/t(j-1)*const2
        rom=miu*den
        rom2=miu*den/prandtl
        !
        p0= f(j-1)+f1(j-1)*dy
        p1=f1(j-1)+f2(j-1)*dy
        p2=f2(j-1)+f3(j-1)/rom*dy
        p3=-1d0*p0*p2
        !
        q0=t(j-1)+t1(j-1)*dy
        miu=miucal(q0)
        den=pinf/q0*const2
        rom=miu*den
        rom2=miu*den/prandtl
        q1=t1(j-1)+t2(j-1)/rom2*dy
        q2=-p0*q1-const5*rom*p2**2
        !
        ! corrector
        miu=miucal(q0)
        den=pinf/q0*const2
        rom=miu*den
        rom2=miu*den/prandtl
        !
        var0= f(j-1)+0.5d0*(f1(j-1)+p1)*dy
        var1=f1(j-1)+0.5d0*(f2(j-1)+p2)*dy
        var2=f2(j-1)+0.5d0*(f3(j-1)+p3)/rom*dy
        var3=-1d0*f(j)*f2(j)
        !
        var4= t(j-1)+0.5d0*(t1(j-1)+q1)*dy
        miu=miucal(var4)
        den=pinf/var4*const2
        rom=miu*den
        rom2=miu*den/prandtl
        var5=t1(j-1)+0.5d0*(t2(j-1)+q2)/rom2*dy
        var6=-var0*var5-const5*rom*var2**2
        !
        ! error calculation
        err=max( err,dabs(var0- f(j)),dabs(var1-f1(j)),        &
                           dabs(var2-f2(j)),dabs(var3-f3(j)),  &
                           dabs(var4- t(j)),dabs(var5-t1(j)),  &
                           dabs(var6-t2(j))                    )
        !
         f(j)=var0
        f1(j)=var1
        f2(j)=var2
        f3(j)=var3
        !
         t(j)=var4
        t1(j)=var5
        t2(j)=var6
        !
      end do
      !
      !
      !print*,'n',n,'err',err
      !
    end do
    !
  end subroutine blasius_solution
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate parallel.info file.                |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 04-04-2022  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine parallelifogen
    !
    use readwrite, only: readinput
    use parallel,  only: mpisizedis,parapp,mpisize,mpirankmax
    !
    call readinput
    !
    mpisize=128*128
    mpirankmax=mpisize-1
    !
    call mpisizedis
    !
    call parapp
    !
  end subroutine parallelifogen
  !+-------------------------------------------------------------------+
  !| The end of the subroutine parallelifogen.                         |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is used to generate an example case.              |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 28-05-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine examplegen(folder)
    !
    use parallel, only: mpirank
    !
    character(len=*),intent(in) :: folder
    integer :: fh
    !
    if(mpirank==0) then
      !
      print*,' ** Generating an example case.'
      !
      call system('mkdir '//trim(folder))
      call system('mkdir '//trim(folder)//'/datin')
      !
      fh=get_unit()
      !
      open(fh,file=trim(folder)//'/datin/input.chl',form='formatted')
      write(fh,'(A)')'########################################################################'
      write(fh,'(A)')'#                     input file of ASTR code                          #'
      write(fh,'(A)')'########################################################################'
      write(fh,*)
      write(fh,'(A)')'# flowtype                                              : The type of flow problem'
      write(fh,'(A)')'channel'
      write(fh,*)
      write(fh,'(A)')'# im,jm,km                                              : The size of grid.'
      write(fh,'(A)')'128,128,128'
      write(fh,*)
      write(fh,'(A)')'# lihomo,ljhomo,lkhomo                                  : The homogeneous directions'
      write(fh,'(A)')'t,f,t'
      write(fh,*)
      write(fh,'(A)')'# nondimen,diffterm,lfilter,lreadgrid,lfftz,limmbou     : Parameters'
      write(fh,'(A)')'t,t,t,t,f,f'
      write(fh,*)
      write(fh,'(A)')'# lrestar                                               : start mode'
      write(fh,'(A)')'f'
      write(fh,*)
      write(fh,'(A)')'# alfa_filter, kcutoff                                  : Filter parameters'
      write(fh,'(A)')'0.49d0, 48'
      write(fh,*)
      write(fh,'(A)')'# ref_t,reynolds,mach                                   : Reference variables'
      write(fh,'(A)')'273.15d0,  3000.d0,  0.5d0 '
      write(fh,*)
      write(fh,'(A)')'# conschm,difschm,rkscheme                              : Numerical scheme'
      write(fh,'(A)')'642c, 642c, rk4 '
      write(fh,*)
      write(fh,'(A)')'# recon_schem, lchardecomp,bfacmpld                     : Parameters for upwind-biased scheme'
      write(fh,'(A)')'0, f, 0.3d0 '
      write(fh,*)
      write(fh,'(A)')'# num_species                                           : number of species'
      write(fh,'(A)')'1'
      write(fh,*)
      write(fh,'(A)')'# turbmode                                              : turbulence model'
      write(fh,'(A)')'none'
      write(fh,*)
      write(fh,'(A)')'# bctype                                                : Boundary condition definition '
      write(fh,'(A)')'1'
      write(fh,'(A)')'1'
      write(fh,'(A)')'41, 1.d0'
      write(fh,'(A)')'41, 1.d0'
      write(fh,'(A)')'1'
      write(fh,'(A)')'1'
      write(fh,*)
      write(fh,'(A)')'# ninit                                                 : Initial method'
      write(fh,'(A)')'1'
      write(fh,*)
      write(fh,'(A)')'# spg_imin,spg_imax,spg_jmin,spg_jmax,spg_kmin,spg_kmax : Sponge layer range'
      write(fh,'(A)')'0, 0, 0, 0, 0, 0'
      write(fh,*)
      write(fh,'(A)')'# gridfile                                              : grid'
      write(fh,'(A)')'./datin/grid.chl'
      write(fh,*)
      write(fh,*)
      write(fh,*)
      write(fh,*)'########################################################################'
      write(fh,*)'# bctype                                                               #'
      write(fh,*)'#   1 : periodic bc,     nothing will be done.                         #'
      write(fh,*)'#  41 : isothermal wall, wall temperature input.                       #'
      write(fh,*)'########################################################################'
      close(fh)
      print*,' << ',trim(folder),'/datin/input.chl'
      !
      call gridchannel(320,128,128,trim(folder))
      !
      open(fh,file=trim(folder)//'/datin/controller',form='formatted')
      write(fh,'(A)')'############################################################'
      write(fh,'(A)')'#               control file for ASTRR code                #'
      write(fh,'(A)')'############################################################'
      write(fh,*)
      write(fh,'(A)')'# lwsequ,lwslic,lavg'
      write(fh,'(A)')'f,f'
      write(fh,*)
      write(fh,'(A)')'# maxstep,nwrite,ninst,nlstep,navg'
      write(fh,'(A)')'1000,100,20,1,20'
      write(fh,*)
      write(fh,'(A)')'# deltat '
      write(fh,'(A)')'1.d-3'
      write(fh,'(A)')'+----------------------------------------------------------+'
      write(fh,'(A)')'| This file will be read each time after checkpoint        |'
      write(fh,'(A)')'+--------------+-------------------------------------------+'
      write(fh,'(A)')'|       lwrite | to write a sequence of flowfield files.   |'
      write(fh,'(A)')'|       lwslic | to write a sequence of slice cut files.   |'
      write(fh,'(A)')'|         lavg | to conduct on-fly stastistics.            |'
      write(fh,'(A)')'+--------------+-------------------------------------------+'
      write(fh,'(A)')'|      maxstep | max step to run.                          |'
      write(fh,'(A)')'|       nwrite | frequency of dumping checkpoint.          |'
      write(fh,'(A)')'|        ninst | frequency of writing slice.               |'
      write(fh,'(A)')'|       nlstep | frequency of listing computing state.     |'
      write(fh,'(A)')'|         navg | frequency of calculating statistics.      |'
      write(fh,'(A)')'+--------------+-------------------------------------------+'
      write(fh,'(A)')'|       deltat | time step.                                |'
      write(fh,'(A)')'+--------------+-------------------------------------------+'
      close(fh)
      print*,' << ',trim(folder),'/datin/controller'
      !
      call system('cp -v ./bin/astr ./'//trim(folder))
      !
      print*,' ** An example case is generated.'
      print*,' ** you can now run a simulation of channel flow by : '
      print*,' mpirun -np 8 ./astr run datin/input.chl'
      !
    endif
    !
  end subroutine examplegen
  !+-------------------------------------------------------------------+
  !| The end of the subroutine examplegen.                             |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is used to convert a streammed data to a          |
  !| structured data.                                                  |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 31-03-2022  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine stream2struc(fname)
    !
    use hdf5io
    !
    character(len=*),intent(in) :: fname
    !
    integer :: fh,isize,jsize,ksize,rankmax,jrank,vai1,irp,jrp,krp,    &
               asizemax,ima,jma,kma,i,j,k,n,nstep
    real(8) :: time
    integer,allocatable :: im(:),jm(:),km(:),i0(:),j0(:),k0(:),        &
                           offset(:),asize(:)
    !
    real(8),allocatable,dimension(:) :: data_1d
    real(8),allocatable,dimension(:,:,:) :: data_3d
    !
    fh=get_unit()
    open(fh,file='datin/parallel.info',form='formatted',action='read')
    read(fh,*)
    read(fh,*)isize,jsize,ksize
    rankmax=isize*jsize*ksize-1
    print*,' ** rankmax=',rankmax
    allocate(im(0:rankmax),jm(0:rankmax),km(0:rankmax),                &
             i0(0:rankmax),j0(0:rankmax),k0(0:rankmax),                &
             offset(0:rankmax),asize(0:rankmax))
    read(fh,*)
    do jrank=0,rankmax
      read(fh,*)vai1,irp,jrp,krp,im(jrank),jm(jrank),km(jrank),        &
                i0(jrank),j0(jrank),k0(jrank)
    enddo
    close(fh)
    print*,' >> datin/parallel.info'
    !
    do jrank=0,rankmax
      asize(jrank)=(im(jrank)+1)*(jm(jrank)+1)*(km(jrank)+1)
    enddo
    !
    offset(0)=0
    do jrank=1,rankmax
      offset(jrank)=offset(jrank-1)+asize(jrank-1)
    enddo
    !
    asizemax=offset(rankmax)+asize(rankmax)
    !
    ima=i0(rankmax)+im(rankmax)
    jma=j0(rankmax)+jm(rankmax)
    kma=k0(rankmax)+km(rankmax)
    !
    print*,' **     stream data size:',asizemax
    print*,' ** structured data size:',ima,jma,kma
    ! !
    allocate( data_1d(1:asizemax),data_3d(0:ima,0:jma,0:kma) )
    !
    call h5sread(varname='nstep',var=nstep,filename=fname//'.s5')
    call h5srite(var=nstep,varname='nstep',filename=fname//'.h5',newfile=.true.)
    !
    if(fname=='outdat/flowfield') then
      !
      call h5sread(varname='time',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='time',filename=fname//'.h5')
      !
      call data3d_rcw(varname='ro')
      call data3d_rcw(varname='u1')
      call data3d_rcw(varname='u2')
      call data3d_rcw(varname='u3')
      call data3d_rcw(varname='p')
      call data3d_rcw(varname='t')
      !
    elseif(fname=='outdat/meanflow') then
      !
      call h5sread(varname='nsamples',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nsamples',filename=fname//'.h5')
      !
      call h5sread(varname='nstep_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nstep_sbeg',filename=fname//'.h5')
      !
      call h5sread(varname='time_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='time_sbeg',filename=fname//'.h5')
      !
      call data3d_rcw(varname='rom')
      call data3d_rcw(varname='u1m')
      call data3d_rcw(varname='u2m')
      call data3d_rcw(varname='u3m')
      call data3d_rcw(varname='pm')
      call data3d_rcw(varname='tm')
      !
    elseif(fname=='outdat/2ndsta') then
      !
      call h5sread(varname='nsamples',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nsamples',filename=fname//'.h5')
      !
      call h5sread(varname='nstep_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nstep_sbeg',filename=fname//'.h5')
      !
      call h5sread(varname='time_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='time_sbeg',filename=fname//'.h5')
      !
      call data3d_rcw(varname= 'pp')
      call data3d_rcw(varname= 'tt')
      call data3d_rcw(varname='tu1')
      call data3d_rcw(varname='tu2')
      call data3d_rcw(varname='tu3')
      call data3d_rcw(varname='u11')
      call data3d_rcw(varname='u12')
      call data3d_rcw(varname='u13')
      call data3d_rcw(varname='u22')
      call data3d_rcw(varname='u23')
      call data3d_rcw(varname='u33')
      !
    elseif(fname=='outdat/3rdsta') then
      !
      call h5sread(varname='nsamples',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nsamples',filename=fname//'.h5')
      !
      call h5sread(varname='nstep_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nstep_sbeg',filename=fname//'.h5')
      !
      call h5sread(varname='time_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='time_sbeg',filename=fname//'.h5')
      !
      call data3d_rcw(varname='u111')
      call data3d_rcw(varname='u112')
      call data3d_rcw(varname='u113')
      call data3d_rcw(varname='u122')
      call data3d_rcw(varname='u123')
      call data3d_rcw(varname='u133')
      call data3d_rcw(varname='u222')
      call data3d_rcw(varname='u223')
      call data3d_rcw(varname='u233')
      call data3d_rcw(varname='u333')
      !
    elseif(fname=='outdat/budget') then
      !
      call h5sread(varname='nsamples',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nsamples',filename=fname//'.h5')
      !
      call h5sread(varname='nstep_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='nstep_sbeg',filename=fname//'.h5')
      !
      call h5sread(varname='time_sbeg',var=time,filename=fname//'.s5')
      call h5srite(var=time,varname='time_sbeg',filename=fname//'.h5')
      !
      call data3d_rcw(varname= 'predil')
      call data3d_rcw(varname=    'pu1')
      call data3d_rcw(varname=    'pu2')
      call data3d_rcw(varname=    'pu3')
      call data3d_rcw(varname='sgmam11')
      call data3d_rcw(varname='sgmam12')
      call data3d_rcw(varname='sgmam13')
      call data3d_rcw(varname='sgmam22')
      call data3d_rcw(varname='sgmam23')
      call data3d_rcw(varname='sgmam33')
      call data3d_rcw(varname=  'u1rem')
      call data3d_rcw(varname=  'u2rem')
      call data3d_rcw(varname=  'u3rem')
      call data3d_rcw(varname='visdif1')
      call data3d_rcw(varname='visdif2')
      call data3d_rcw(varname='visdif3')
      !
    else
      stop ' !! file name error @ stream2struc'
    endif
    !
    contains
    !
    subroutine data3d_rcw(varname)
      !
      character(len=*),intent(in) :: varname
      !
      call h5sread(varname=varname,var= data_1d,dim=asizemax,filename=fname//'.s5')
      !
      write(*,'(A)',advance='no')'  ** data converting ... '
      do jrank=0,rankmax
        !
        n=offset(jrank)
        !
        do k=k0(jrank),k0(jrank)+km(jrank)
        do j=j0(jrank),j0(jrank)+jm(jrank)
        do i=i0(jrank),i0(jrank)+im(jrank)
          !
          n=n+1
          !
          data_3d(i,j,k)=data_1d(n)
          !
        enddo
        enddo
        enddo
        !
        write(*,'(1A1,A,I4,A,$)')char(13),'  ** data converting ... ', &
                                                100*jrank/rankmax,'  % '
        !
      enddo
      write(*,*)''
      !
      call h5srite(var=data_3d,varname=varname,filename=fname//'.h5')
      !
    end subroutine data3d_rcw
    !
  end subroutine stream2struc
  !+-------------------------------------------------------------------+
  !| The end of the subroutine stream2struc.                           |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is used to generate an example grid.              |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 28-05-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine gridchannel(im,jm,km,folder)
    !
    use tecio
    use hdf5io
    use constdef
    use commfunc, only : argtanh
    !
    integer,intent(in) :: im,jm,km
    character(len=*),intent(in) :: folder
    !
    real(8),allocatable,dimension(:,:,:) :: x,y,z
    integer :: npa,n,i,j,k,jmm,fh
    real(8) :: varc,var1,var2,Retau,dx
    !
    allocate(x(0:im,0:jm,0:km),y(0:im,0:jm,0:km),z(0:im,0:jm,0:km))
    !
    Retau=185.d0
    jmm=jm/2
    !
    varc=1.075d0
    do j=0,jm
      !
      var1=argtanh(1.d0/varc)
      var2=2.d0*(j)/(jm)*1.d0-1.d0
      !
      y(0,j,0)=1.d0*(1.d0+varc*dtanh(var1*var2))
      !
    end do
    !
    do k=0,km
    do j=0,jm
    do i=0,im
      x(i,j,k)=4.d0*pi/im*i
      y(i,j,k)=y(0,j,0)
      !
      if(km==0) then
        z(i,j,k)=0.d0
      else
        z(i,j,k)=num4d3*pi/km*k
      endif
    end do
    end do
    end do
    print*,' ** y1+=',y(0,1,0)*Retau
    print*,' ** ym+=',(y(0,jmm,0)-y(0,jmm-1,0))*Retau
    print*,' ** dx+=',(x(1,0,0)-x(0,0,0))*Retau,(x(1,0,0)-x(0,0,0))
    print*,' ** dz+=',(z(0,0,1)-z(0,0,0))*Retau,(z(0,0,1)-z(0,0,0))
    print*,' ** lx+=',(x(im,0,0)-x(0,0,0))*Retau
    print*,' ** lz+=',(z(0,0,km)-z(0,0,0))*Retau
    !
    fh=get_unit()
    open(fh,file='dy.dat')
    write(fh,*)(j*1.d0,y(0,j,0),y(0,j,0)-y(0,j-1,0),j=1,jm)
    close(fh)
    print*,' << dy.dat'
    !
    ! call writetecbin('Testout/tecgrid.plt',x,'x',y,'y',z,'z')
    !
    call h5srite(x,'x',folder//'/datin/grid.chl',newfile=.true.)
    call h5srite(y,'y',folder//'/datin/grid.chl')
    call h5srite(z,'z',folder//'/datin/grid.chl')
    !
    !
    deallocate(x,y,z)
    !
  end subroutine gridchannel
  !+-------------------------------------------------------------------+
  !| The end of the subroutine gridchannel.                            |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to process solid file to improve its accuracy. |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidpp
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro,solidrota
    use tecio,    only : tecsolid
    use stlaio,   only : stla_write
    use cmdefne,  only : readkeyboad
    !
    ! arguments
    !
    ! local data
    integer :: js
    character(len=64) :: inputfile
    character(len=4) :: cmd
    real(8) :: resc_fact
    real(8) :: rot_vec(3),rot_theta,shift_cor(3)
    !
    call readkeyboad(cmd)
    !
    print*,cmd
    !
    if(cmd=='sgen') then
      call solidgen_circle
      !
      shift_cor=(/5.d0,2.5d0,0.d0/)
      !
    elseif(cmd=='proc') then
      call readkeyboad(inputfile)
      !
      call readsolid(trim(inputfile))
      !
      ! resc_fact=0.015d0
      resc_fact=0.005d0
      rot_vec=(/1.d0,0.d0,0.d0/)
      rot_theta=-90.d0
      shift_cor=(/5.d0,5.d0,5.d0/)
    else
      !
      print*,' !! ERROR 1, cmd not defined !!'
      print*,' ** cmd=',cmd
      print*,' ** inputfile',inputfile
      !
      stop
      !
    endif
    !
    ! 
    ! call solidgen_circle
    ! call solidgen_cub
    ! call solidgen_triagnle
    ! call solidgen_airfoil
    !
    do js=1,nsolid
      call solidrange(immbody(js))
      !
      ! call solidresc(immbody(js),resc_fact)
      ! call solidrota(immbody(js),rot_theta,rot_vec)
      call solidshif(immbody(js),x=shift_cor(1)-immbody(js)%xcen(1),  &
                                 y=shift_cor(2)-immbody(js)%xcen(2),  &
                                 z=shift_cor(3)-immbody(js)%xcen(3))
      !
    enddo
    !
    !
    !
    !
    ! do js=1,nsolid
    !   call solidimpro(immbody(js))
    ! enddo
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    call stla_write('solid_in.stl',immbody)
    !
  end subroutine solidpp
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidpp.                                |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a solid usign stl file format.     |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_airfoil
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product,argtanh
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi, &
               x1(3),x2(3),x3(3),x4(3),x5(3),x6(3),norm1(3),var1,var2, &
               xc,yc
    real(8) :: epsilon,varc,theter
    integer :: map
    character(len=4) :: nacaname
    real(8),allocatable :: xap(:),yap(:),xin(:)
    type(triangle),allocatable :: tempface(:)
    !
    epsilon=1.d-12
    !
    print*,' ** generating solid'
    !
    map=1024
    nacaname='4412'
    allocate(xin(0:map),xap(0:map),yap(0:map))
    !
    varc=1.02d0
    do i=0,map/2
      !
      var1=argtanh(1.d0/varc)
      var2=2.d0*(i)/(map)*1.d0-1.d0
      !
      xin(i)=1.d0*(1.d0+varc*dtanh(var1*var2))
      call naca4digit(xin(i),xap(i),yap(i),nacaname,'upper')
      !
    end do
    !
    do i=map/2+1,map
      xin(i)=xin(map-i)
      call naca4digit(xin(i),xap(i),yap(i),nacaname,'lower')
    enddo
    !
    print*,' ** input angle of attack in degree'
    read(*,*)theter
    !
    theter=-theter/180.d0*pi
    !
    do i=0,map
      var1=xap(i)*cos(theter)-yap(i)*sin(theter)
      var2=xap(i)*sin(theter)+yap(i)*cos(theter)
      xap(i)=var1
      yap(i)=var2
    enddo
    !
    open(18,file='naca'//nacaname//'.dat')
    do i=0,map
      write(18,*)xap(i),yap(i)
    enddo
    close(18)
    print*,' << naca',nacaname,'.dat'
    !
    ! open(12,file='naca4412.dat')
    ! read(12,*)map
    ! allocate(xap(map),yap(map))
    ! do i=1,map
    !   read(12,*)xap(i),yap(i)
    ! enddo
    ! close(12)
    ! print*,' << naca4412.dat'
    !
    nface=0
    !
    xc=0.d0
    yc=0.d0
    do i=1,map-1
      xc=xc+xap(i)
      yc=yc+yap(i)
    enddo
    !
    xc=xc/dble(map-1)
    yc=yc/dble(map-1)
    !
    nsolid=1
    allocate(immbody(nsolid))
    immbody(1)%name='cube'
    !
    allocate(tempface(map*16))
    !
    do i=0,map-1
      x1(1)=xap(i)
      x1(2)=yap(i)
      x1(3)=0.d0
      !
      x2(1)=xap(i+1)
      x2(2)=yap(i+1)
      x2(3)=0.d0
      !
      x3(1)=xap(i+1)
      x3(2)=yap(i+1)
      x3(3)=1.d0
      !
      x4(1)=xap(i)
      x4(2)=yap(i)
      x4(3)=1.d0
      !
      x5(1)=xc
      x5(2)=yc
      x5(3)=0.d0
      !
      x6(1)=xc
      x6(2)=yc
      x6(3)=1.d0
      !
      nface=nface+1
      tempface(nface)%a=x1
      tempface(nface)%b=x2
      tempface(nface)%c=x3
      tempface(nface)%normdir=cross_product(x3-x1,x2-x1)
      !
      nface=nface+1
      tempface(nface)%a=x3
      tempface(nface)%b=x4
      tempface(nface)%c=x1
      tempface(nface)%normdir=cross_product(x1-x3,x4-x3)
      !
      nface=nface+1
      tempface(nface)%a=x1
      tempface(nface)%b=x2
      tempface(nface)%c=x5
      tempface(nface)%normdir=(/0.d0,0.d0,-1.d0/)
      !
      nface=nface+1
      tempface(nface)%a=x4
      tempface(nface)%b=x3
      tempface(nface)%c=x6
      tempface(nface)%normdir=(/0.d0,0.d0,1.d0/)
      !
    enddo
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_airfoil
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidgen_airfoil.                       |
  !+-------------------------------------------------------------------+
  !
  
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a mvg solid usign stl file format. |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 22-10-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_mvg
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi, &
               x1(3),x2(3),x3(3),x4(3),norm1(3),var1,var2
    real(8) :: epsilon,delta,x0,lx,lz,h,sz,chord
    type(triangle),allocatable :: tempface(:)
    !
    epsilon=1.d-12
    delta=1.d0
    x0=10.d0
    lx=2.523597432d0
    lz=2.25d0
    chord=sqrt(lx**2+0.25d0*lz**2)
    sz=0.25d0
    h =0.3838d0
    nface=0
    !
    print*,' ** generating solid'
    !
    nsolid=2
    allocate(immbody(nsolid))
    immbody(1)%name='mvg1'
    !
    allocate(tempface(12))
    !
    x1(1)=x0
    x1(2)=0.d0
    x1(3)=0.5d0*sz
    !
    x2(1)=x0
    x2(2)=0.d0
    x2(3)=0.5d0*sz+lz
    !
    x3(1)=x0+lx
    x3(2)=0.d0
    x3(3)=0.5d0*sz+0.5d0*lz
    !
    x4(1)=x0+lx
    x4(2)=0.d0+h
    x4(3)=0.5d0*sz+0.5d0*lz
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,-1.d0,0.d0/)
    !
    var1=0.5d0*lz/chord
    var2=      lx/chord
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x3
    tempface(nface)%c=x4
    tempface(nface)%normdir=(/var1,0.d0,-var2/)
    !
    var1=0.5d0*lz/chord
    var2=      lx/chord
    nface=nface+1
    tempface(nface)%a=x2
    tempface(nface)%b=x3
    tempface(nface)%c=x4
    tempface(nface)%normdir=(/var1,0.d0,var2/)
    !
    var1=h /sqrt(lx**2+h**2)
    var2=lx/sqrt(lx**2+h**2)
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x4
    tempface(nface)%normdir=(/-var1,var2,0.d0/)
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    nface=0
    !
    x1(3)=x1(3)+sz+lz
    x2(3)=x2(3)+sz+lz
    x3(3)=x3(3)+sz+lz
    x4(3)=x4(3)+sz+lz
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,-1.d0,0.d0/)
    !
    var1=0.5d0*lz/chord
    var2=      lx/chord
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x3
    tempface(nface)%c=x4
    tempface(nface)%normdir=(/var1,0.d0,-var2/)
    !
    var1=0.5d0*lz/chord
    var2=      lx/chord
    nface=nface+1
    tempface(nface)%a=x2
    tempface(nface)%b=x3
    tempface(nface)%c=x4
    tempface(nface)%normdir=(/var1,0.d0, var2/)
    !
    var1=h /sqrt(lx**2+h**2)
    var2=lx/sqrt(lx**2+h**2)
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x4
    tempface(nface)%normdir=(/-var1,var2,0.d0/)
    !
    immbody(2)%num_face=nface
    call immbody(2)%alloface()
    immbody(2)%face(1:nface)=tempface(1:nface)
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_mvg
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a solid usign stl file format.     |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_triagnle
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi, &
               x1(3),x2(3),x3(3),x4(3),norm1(3),var1
    real(8) :: epsilon
    type(triangle),allocatable :: tempface(:)
    !
    epsilon=1.d-12
    !
    print*,' ** generating solid'
    !
    nsolid=1
    allocate(immbody(nsolid))
    immbody(1)%name='cube'
    !
    allocate(tempface(12))
    !
    nface=0
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=1.d0
    x2(2)=-0.5d0
    x2(3)=0.d0
    !
    x3(1)=1.d0
    x3(2)=0.5d0
    x3(3)=0.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,0.d0,-1.d0/)
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=1.d0
    !
    x2(1)=1.d0
    x2(2)=-0.5d0
    x2(3)=1.d0
    !
    x3(1)=1.d0
    x3(2)=0.5d0
    x3(3)=1.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,0.d0, 1.d0/)
    !
    x1(1)=1.d0
    x1(2)=-0.5d0
    x1(3)=0.d0
    !
    x2(1)=1.d0
    x2(2)=-0.5d0
    x2(3)=1.d0
    !
    x3(1)=1.d0
    x3(2)=0.5d0
    x3(3)=1.d0
    !
    x4(1)=1.d0
    x4(2)=0.5d0
    x4(3)=0.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/1.d0,0.d0,0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/1.d0,0.d0,0.d0/)
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=0.d0
    x2(2)=0.d0
    x2(3)=1.d0
    !
    x3(1)=1.d0
    x3(2)=0.5d0
    x3(3)=1.d0
    !
    x4(1)=1.d0
    x4(2)=0.5d0
    x4(3)=0.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/-1.d0/sqrt(5.d0),2.d0/sqrt(5.d0),0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/-1.d0/sqrt(5.d0),2.d0/sqrt(5.d0),0.d0/)
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=0.d0
    x2(2)=0.d0
    x2(3)=1.d0
    !
    x3(1)=1.d0
    x3(2)=-0.5d0
    x3(3)=1.d0
    !
    x4(1)=1.d0
    x4(2)=-0.5d0
    x4(3)=0.d0
    !
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/-1.d0/sqrt(5.d0),-2.d0/sqrt(5.d0),0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/-1.d0/sqrt(5.d0),-2.d0/sqrt(5.d0),0.d0/)
    !
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_triagnle
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidgen_triagnle.                      |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a solid usign stl file format.     |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_cub
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi, &
               x1(3),x2(3),x3(3),x4(3),norm1(3),var1
    real(8) :: epsilon
    type(triangle),allocatable :: tempface(:)
    !
    epsilon=1.d-12
    !
    print*,' ** generating solid'
    !
    nsolid=1
    allocate(immbody(nsolid))
    immbody(1)%name='cube'
    !
    allocate(tempface(12))
    nface=0
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=1.d0
    x2(2)=0.d0
    x2(3)=0.d0
    !
    x3(1)=1.d0
    x3(2)=1.d0
    x3(3)=0.d0
    !
    x4(1)=0.d0
    x4(2)=1.d0
    x4(3)=0.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,0.d0,-1.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/0.d0,0.d0,-1.d0/)
    !
    x1(1)=1.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=1.d0
    x2(2)=0.d0
    x2(3)=1.d0
    !
    x3(1)=1.d0
    x3(2)=1.d0
    x3(3)=1.d0
    !
    x4(1)=1.d0
    x4(2)=1.d0
    x4(3)=0.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/1.d0,0.d0,0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/1.d0,0.d0,0.d0/)
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=0.d0
    x2(2)=0.d0
    x2(3)=1.d0
    !
    x3(1)=0.d0
    x3(2)=1.d0
    x3(3)=1.d0
    !
    x4(1)=0.d0
    x4(2)=1.d0
    x4(3)=0.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/-1.d0,0.d0,0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/-1.d0,0.d0,0.d0/)
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=1.d0
    !
    x2(1)=1.d0
    x2(2)=0.d0
    x2(3)=1.d0
    !
    x3(1)=1.d0
    x3(2)=1.d0
    x3(3)=1.d0
    !
    x4(1)=0.d0
    x4(2)=1.d0
    x4(3)=1.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,0.d0,1.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/0.d0,0.d0,1.d0/)
    !
    x1(1)=0.d0
    x1(2)=0.d0
    x1(3)=0.d0
    !
    x2(1)=1.d0
    x2(2)=0.d0
    x2(3)=0.d0
    !
    x3(1)=1.d0
    x3(2)=0.d0
    x3(3)=1.d0
    !
    x4(1)=0.d0
    x4(2)=0.d0
    x4(3)=1.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,-1.d0,0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    tempface(nface)%normdir=(/0.d0,-1.d0,0.d0/)
    !
    x1(1)=0.d0
    x1(2)=1.d0
    x1(3)=0.d0
    !
    x2(1)=1.d0
    x2(2)=1.d0
    x2(3)=0.d0
    !
    x3(1)=1.d0
    x3(2)=1.d0
    x3(3)=1.d0
    !
    x4(1)=0.d0
    x4(2)=1.d0
    x4(3)=1.d0
    !
    nface=nface+1
    tempface(nface)%a=x1
    tempface(nface)%b=x2
    tempface(nface)%c=x3
    tempface(nface)%normdir=(/0.d0,1.d0,0.d0/)
    !
    nface=nface+1
    tempface(nface)%a=x3
    tempface(nface)%b=x4
    tempface(nface)%c=x1
    
    tempface(nface)%normdir=(/0.d0,1.d0,0.d0/)
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_cub
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidgen_cub.                           |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a sphere STL file with many        |
  !| equilateral triangle.                                             |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_sphere_tri
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product,dis2point
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface,nface2,jface,ntrimax,m,n,l
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi,   &
               x1(3),x2(3),x3(3),x4(3),norm1(3),norm2(3),var1,var2, &
               ab(3),ac(3),bc(3),abc(3),xico(12,3),disab,disac,disbc
    integer :: lmnsav(120,3)
    real(8) :: epsilon
    type(triangle),allocatable :: tempface(:),tempface2(:)
    !
    epsilon=1.d-12
    ntrimax=10000
    !
    print*,' ** generating solid'
    !
    nsolid=1
    allocate(immbody(nsolid))
    immbody(1)%name='sphere'
    !
    allocate(tempface(ntrimax),tempface2(2*ntrimax))
    !
    ! first build a icosahedron
    !
    var1=0.5d0*(sqrt(5.d0)+1.d0)
    !
    xico(1,1)=0.d0; xico(2,1)= 0.d0; xico(3,1)= 0.d0; xico(4,1)= 0.d0
    xico(1,2)=1.d0; xico(2,2)= 1.d0; xico(3,2)=-1.d0; xico(4,2)=-1.d0
    xico(1,3)=var1; xico(2,3)=-var1; xico(3,3)=-var1; xico(4,3)= var1
    !
    xico(5,1)=1.d0; xico(6,1)= 1.d0; xico(7,1)=-1.d0; xico(8,1)=-1.d0
    xico(5,2)=var1; xico(6,2)=-var1; xico(7,2)=-var1; xico(8,2)= var1
    xico(5,3)=0.d0; xico(6,3)= 0.d0; xico(7,3)= 0.d0; xico(8,3)= 0.d0
    !
    xico(9,1)=var1; xico(10,1)=-var1; xico(11,1)=-var1; xico(12,1)= var1
    xico(9,2)=0.d0; xico(10,2)= 0.d0; xico(11,2)= 0.d0; xico(12,2)= 0.d0
    xico(9,3)=1.d0; xico(10,3)= 1.d0; xico(11,3)=-1.d0; xico(12,3)=-1.d0
    !
    radi=sqrt(xico(1,1)**2+xico(1,2)**2+xico(1,3)**2)
    print*,' ** radi= ',radi
    xico=xico/radi
    var2=2.d0/radi
    !
    nface=0
    lmnsav=0.d0
    do l=1,12
    do m=1,12
    do n=1,12
      !
      disab=abs(dis2point(xico(m,:),xico(n,:))-var2)
      disac=abs(dis2point(xico(l,:),xico(n,:))-var2)
      disbc=abs(dis2point(xico(m,:),xico(l,:))-var2)
      !
      if(disab<epsilon .and. disac<epsilon .and. disbc<epsilon) then
        !
        do i=1,nface
          !
          if( (lmnsav(i,1)==l .and. lmnsav(i,2)==m .and. lmnsav(i,3)==n) .or. &
              (lmnsav(i,1)==l .and. lmnsav(i,2)==n .and. lmnsav(i,3)==m) .or. &
              (lmnsav(i,1)==m .and. lmnsav(i,2)==l .and. lmnsav(i,3)==n) .or. &
              (lmnsav(i,1)==m .and. lmnsav(i,2)==n .and. lmnsav(i,3)==l) .or. &
              (lmnsav(i,1)==n .and. lmnsav(i,2)==l .and. lmnsav(i,3)==m) .or. &
              (lmnsav(i,1)==n .and. lmnsav(i,2)==m .and. lmnsav(i,3)==l) ) then
            exit
          endif
        enddo
        !
        if(i==nface+1) then
          !
          nface=nface+1
          !
          print*,' ** nface= ',nface
          !
          lmnsav(nface,1)=l
          lmnsav(nface,2)=m
          lmnsav(nface,3)=n
          !
          tempface(nface)%a=xico(l,:)
          tempface(nface)%b=xico(m,:)
          tempface(nface)%c=xico(n,:)
          !
          norm1=cross_product(tempface(nface)%b-tempface(nface)%a,         &
                              tempface(nface)%c-tempface(nface)%a )
          norm2=tempface(nface)%a
          !
          if(dot_product(norm1,norm2)<0.d0) then
            !
            tempface(nface)%a=xico(l,:)
            tempface(nface)%b=xico(n,:)
            tempface(nface)%c=xico(m,:)
            !
            norm1=cross_product(tempface(nface)%b-tempface(nface)%a,         &
                                tempface(nface)%c-tempface(nface)%a )
            norm2=tempface(nface)%a
            !
          endif
          !
          !
        endif
        !
      endif
      !
    enddo
    enddo
    enddo
    !
    do while(nface<ntrimax)
      !
      nface2=0
      !
      do jface=1,nface
        !
        ab=0.5d0*(tempface(jface)%a+tempface(jface)%b)
        ac=0.5d0*(tempface(jface)%a+tempface(jface)%c)
        bc=0.5d0*(tempface(jface)%b+tempface(jface)%c)
        abc=num1d3*(tempface(jface)%a+tempface(jface)%b+tempface(jface)%c)
        !
        var1=sqrt(ab(1)**2+ab(2)**2+ab(3)**2)
        ab=ab/var1
        var1=sqrt(ac(1)**2+ac(2)**2+ac(3)**2)
        ac=ac/var1
        var1=sqrt(bc(1)**2+bc(2)**2+bc(3)**2)
        bc=bc/var1
        var1=sqrt(abc(1)**2+abc(2)**2+abc(3)**2)
        abc=abc/var1
        !
        nface2=nface2+1
        tempface2(nface2)%a=tempface(jface)%a
        tempface2(nface2)%b=ab
        tempface2(nface2)%c=ac
        !
        nface2=nface2+1
        tempface2(nface2)%a=tempface(jface)%b
        tempface2(nface2)%b=ab
        tempface2(nface2)%c=bc
        !
        nface2=nface2+1
        tempface2(nface2)%a=tempface(jface)%c
        tempface2(nface2)%b=ac
        tempface2(nface2)%c=bc
        !
        nface2=nface2+1
        tempface2(nface2)%a=ab
        tempface2(nface2)%b=ac
        tempface2(nface2)%c=bc
        !
        if(nface2>ntrimax) exit
        !
      enddo
      !
      if(nface2>ntrimax) exit
      !
      nface=nface2
      tempface=tempface2
      !
      print*,' ** nface=',nface
      !
    enddo
    !
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    do jf=1,immbody(1)%num_face
      !
      norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%b,         &
                          immbody(1)%face(jf)%c-immbody(1)%face(jf)%b )
      norm2=immbody(1)%face(jf)%a
      !
      if(dot_product(norm1,norm2)<0.d0) then
        x1=immbody(1)%face(jf)%c
        immbody(1)%face(jf)%c=immbody(1)%face(jf)%a
        immbody(1)%face(jf)%a=x1
        !
        norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%b,       &
                            immbody(1)%face(jf)%c-immbody(1)%face(jf)%b )
      endif
      !
      var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
      !
      if(abs(var1)<epsilon) then
        !
        norm1=cross_product(immbody(1)%face(jf)%C-immbody(1)%face(jf)%a,         &
                            immbody(1)%face(jf)%b-immbody(1)%face(jf)%a )
        !
        var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
        !
      endif
      !
      if(abs(var1)<epsilon) then
        !
        norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%c,         &
                            immbody(1)%face(jf)%b-immbody(1)%face(jf)%c )
        !
        var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
        !
      endif
      !
      immbody(1)%face(jf)%normdir=norm1/var1
      !
      if(isnan(immbody(1)%face(jf)%normdir(1))) then
        print*,jf
        print*,immbody(1)%face(jf)%a
        print*,immbody(1)%face(jf)%b
        print*,immbody(1)%face(jf)%c
        print*,norm1,'|',var1
        stop
      endif
      !
    enddo
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_sphere_tri
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidgen_sphere_tri.                    |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a solid usign stl file format.     |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 05-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_sphere
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi, &
               x1(3),x2(3),x3(3),x4(3),norm1(3),var1
    real(8) :: epsilon
    type(triangle),allocatable :: tempface(:)
    !
    epsilon=1.d-12
    !
    print*,' ** generating solid'
    !
    nsolid=1
    allocate(immbody(nsolid))
    immbody(1)%name='sphere'
    !
    km=16
    jm=32
    !
    allocate(tempface(km*jm*2))
    !
    dthe=2.d0*pi/km
    dphi=pi/jm
    radi=0.5d0
    !
    nface=0
    !
    do k=0,km-1
    do j=0,jm-1
      !
      theter1=dthe*k
      theter2=dthe*(k+1)
      phi1=dphi*j
      phi2=dphi*(j+1)
      !
      x1(1)=radi*sin(phi1)*cos(theter1)
      x1(2)=radi*sin(phi1)*sin(theter1)
      x1(3)=radi*cos(phi1)
      !
      x2(1)=radi*sin(phi2)*cos(theter1)
      x2(2)=radi*sin(phi2)*sin(theter1)
      x2(3)=radi*cos(phi2)
      !
      x3(1)=radi*sin(phi2)*cos(theter2)
      x3(2)=radi*sin(phi2)*sin(theter2)
      x3(3)=radi*cos(phi2)
      !
      x4(1)=radi*sin(phi1)*cos(theter2)
      x4(2)=radi*sin(phi1)*sin(theter2)
      x4(3)=radi*cos(phi1)
      !
      if(abs(sin(phi1))<epsilon) then
        !
        nface=nface+1
        tempface(nface)%a=x1
        tempface(nface)%b=x2
        tempface(nface)%c=x3
        !
      elseif(abs(sin(phi2))<epsilon) then
        !
        nface=nface+1
        tempface(nface)%a=x3
        tempface(nface)%b=x4
        tempface(nface)%c=x1
        !
      else
        !
        nface=nface+1
        tempface(nface)%a=x1
        tempface(nface)%b=x2
        tempface(nface)%c=x3
        !
        nface=nface+1
        tempface(nface)%a=x3
        tempface(nface)%b=x4
        tempface(nface)%c=x1
        !
      endif
      !
    enddo
    enddo
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    do jf=1,immbody(1)%num_face
      !
      norm1=cross_product(immbody(1)%face(jf)%b-immbody(1)%face(jf)%a,         &
                          immbody(1)%face(jf)%c-immbody(1)%face(jf)%a )
      !
      var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
      !
      if(abs(var1)<epsilon) then
        !
        norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%b,         &
                            immbody(1)%face(jf)%c-immbody(1)%face(jf)%b )
        !
        var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
        !
      endif
      !
      if(abs(var1)<epsilon) then
        !
        norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%c,         &
                            immbody(1)%face(jf)%b-immbody(1)%face(jf)%c )
        !
        var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
        !
      endif
      !
      immbody(1)%face(jf)%normdir=norm1/var1
      !
      if(isnan(immbody(1)%face(jf)%normdir(1))) then
        print*,jf
        print*,immbody(1)%face(jf)%a
        print*,immbody(1)%face(jf)%b
        print*,immbody(1)%face(jf)%c
        print*,norm1,'|',var1
        stop
      endif
      !
    enddo
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_sphere
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidgen_sphere.                        |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is to generate a solid usign stl file format.     |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 06-07-2021  | Created by J. Fang @ Warrington                     |
  !+-------------------------------------------------------------------+
  subroutine solidgen_circle
    !
    use commtype, only : solid,triangle
    use readwrite,only : readsolid
    use commvar,  only : nsolid,immbody
    use geom,     only : solidrange,solidresc,solidshif,solidimpro
    use tecio,     only : tecsolid
    use stlaio,    only : stla_write
    use commfunc,  only : cross_product
    !
    ! local data
    integer :: i,j,k,jf,km,jm,im,nface
    real(8) :: dthe,dphi,theter1,theter2,phi1,phi2,radi, &
               x1(3),x2(3),x3(3),x4(3),x5(3),x6(3),norm1(3),var1,xcent(3)
    real(8) :: epsilon
    type(triangle),allocatable :: tempface(:)
    !
    epsilon=1.d-12
    !
    print*,' ** generating solid'
    !
    nsolid=1
    allocate(immbody(nsolid))
    immbody(1)%name='circle'
    !
    km=360
    !
    allocate(tempface(km*4))
    !
    dthe=2.d0*pi/km
    radi=0.5d0
    !
    nface=0
    !
    do k=0,km-1
      !
      theter1=dthe*k
      theter2=dthe*(k+1)
      !
      x1(1)=radi*cos(theter1)
      x1(2)=radi*sin(theter1)
      x1(3)=-0.01d0
      !
      x2(1)=radi*cos(theter2)
      x2(2)=radi*sin(theter2)
      x2(3)=-0.01d0
      !
      x3(1)=radi*cos(theter2)
      x3(2)=radi*sin(theter2)
      x3(3)=0.01d0
      !
      x4(1)=radi*cos(theter1)
      x4(2)=radi*sin(theter1)
      x4(3)=0.01d0
      !
      x5(1)=0.d0
      x5(2)=0.d0
      x5(3)=-0.01d0
      !
      x6(1)=0.d0
      x6(2)=0.d0
      x6(3)=0.01d0
      !
      nface=nface+1
      tempface(nface)%a=x1
      tempface(nface)%b=x2
      tempface(nface)%c=x3
      !
      nface=nface+1
      tempface(nface)%a=x3
      tempface(nface)%b=x4
      tempface(nface)%c=x1
      !
      nface=nface+1
      xcent=(/0.d0,0.d0,-0.01d0/)
      tempface(nface)%a=x1
      tempface(nface)%b=x2
      tempface(nface)%c=xcent
      ! !
      nface=nface+1
      xcent=(/0.d0,0.d0,0.01d0/)
      tempface(nface)%a=x3
      tempface(nface)%b=x4
      tempface(nface)%c=xcent
      !
    enddo
    !
    immbody(1)%num_face=nface
    call immbody(1)%alloface()
    immbody(1)%face(1:nface)=tempface(1:nface)
    !
    do jf=1,immbody(1)%num_face
      !
      norm1=cross_product(immbody(1)%face(jf)%b-immbody(1)%face(jf)%a,         &
                          immbody(1)%face(jf)%c-immbody(1)%face(jf)%a )
      !
      var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
      !
      if(abs(var1)<epsilon) then
        !
        norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%b,         &
                            immbody(1)%face(jf)%c-immbody(1)%face(jf)%b )
        !
        var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
        !
      endif
      !
      if(abs(var1)<epsilon) then
        !
        norm1=cross_product(immbody(1)%face(jf)%a-immbody(1)%face(jf)%c,         &
                            immbody(1)%face(jf)%b-immbody(1)%face(jf)%c )
        !
        var1=sqrt(norm1(1)**2+norm1(2)**2+norm1(3)**2)
        !
      endif
      !
      immbody(1)%face(jf)%normdir=norm1/var1
      !
      if(isnan(immbody(1)%face(jf)%normdir(1))) then
        print*,jf
        print*,immbody(1)%face(jf)%a
        print*,immbody(1)%face(jf)%b
        print*,immbody(1)%face(jf)%c
        print*,norm1,'|',var1
        stop
      endif
      !
    enddo
    !
    call tecsolid('tecsolid.plt',immbody)
    !
    print*,' ** solid generated'
    !
  end subroutine solidgen_circle
  !+-------------------------------------------------------------------+
  !| The end of the subroutine solidgen_circle.                        |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This function is to generate a  4-digit NACA airfoil.             |
  !+-------------------------------------------------------------------+
  !| ref: https://en.wikipedia.org/wiki/NACA_airfoil                   |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 28-Jul-2021: Created by J. Fang @ Appleton                        |
  !+-------------------------------------------------------------------+
  subroutine naca4digit(xin,x,y,name,surface)
    !
    ! arguments
    real(8),intent(in) :: xin
    real(8),intent(out) :: x,y
    character(len=4),intent(in) :: name
    character(len=5),intent(in) :: surface
    !
    ! local data 
    real(8) :: yt,t,yc,theter,mr,pr
    integer :: m,p
    !
    read(name(1:1),*)m
    read(name(2:2),*)p
    read(name(3:4),*)t
    !
    t=t/100.d0
    !
    yt=5.d0*t*(0.2969d0*sqrt(xin)-0.1260d0*xin-0.3516d0*xin*xin+       &
               0.2843d0*xin**3-0.1036d0*xin**4)
    !
    if(p==0 .and. m==0) then
      ! NACA-00XX, a symmetrical 4-digit NACA airfoil
      !
      if(surface=='upper') then
        x=xin
        y=yt
      elseif(surface=='lower') then
        x=xin
        y=-yt
      else
        print*,' surface=',surface
        stop '!! ERROR 1 @ naca4digit'
      endif
      !
    else
      !
      mr=0.01d0*dble(m)
      pr=0.1d0*dble(p)
      !
      if(xin>=0.d0 .and. xin<=pr) then
        yc=mr/pr/pr*(2.d0*pr*xin-xin*xin)
        theter=atan(2.d0*mr/pr/pr*(pr-xin))
      elseif(xin>=pr .and. xin<=1.d0) then
        yc=mr/(1-pr)**2*(1.d0-2.d0*pr+2.d0*pr*xin-xin**2)
        theter=atan(2.d0*mr/(1-pr)**2*(pr-xin))
      else
        stop '!! ERROR 2 @ naca4digit'
      endif
      !
      if(surface=='upper') then
        x=xin-yt*sin(theter)
        y= yc+yt*cos(theter)
      elseif(surface=='lower') then
        x=xin+yt*sin(theter)
        y= yc-yt*cos(theter)
      else
        print*,' surface=',surface
        stop '!! ERROR 3 @ naca4digit'
      endif
      !
    endif
    !
  end subroutine naca4digit
  !+-------------------------------------------------------------------+
  !| The end of the subroutine naca4digit.                             |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This function is to view flow by postprocess data.                |
  !+-------------------------------------------------------------------+
  !| ref: https://en.wikipedia.org/wiki/NACA_airfoil                   |
  !+-------------------------------------------------------------------+
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 28-Jul-2021: Created by J. Fang @ Appleton                        |
  !+-------------------------------------------------------------------+
  subroutine fieldview(flowfile,outputfile,viewmode,inputfile)
    !
    use hdf5io
    use tecio
    use WriteVTK
    !
    ! arguments
    character(len=*),intent(in) :: flowfile,outputfile,viewmode,inputfile
    !
    ! local data
    integer :: im,jm,km
    logical :: lihomo,ljhomo,lkhomo
    real(8) :: ref_t,reynolds,mach
    character(len=32) :: gridfile
    !
    real(8),allocatable,dimension(:,:) :: x_2d,y_2d,z_2d,ro_2d,u_2d,   &
                                          v_2d,w_2d,p_2d,t_2d
    real(8),allocatable,dimension(:,:,:) :: x,y,z,ro,u,v,w,p,t
    !
    print*,' ==========================readinput=========================='
    !
    open(11,file=inputfile,form='formatted',status='old')
    read(11,'(///////)')
    read(11,*)im,jm,km
    read(11,"(/)")
    read(11,*)lihomo,ljhomo,lkhomo
    read(11,'(//////////)')
    read(11,*)ref_t,reynolds,mach
    read(11,'(///////////////////////////)')
    read(11,'(A)')gridfile
    close(11)
    print*,' >> ',inputfile
    !
    print*,' ** grid file: ',trim(gridfile)
    !
    if(viewmode=='xy') then
      allocate(x_2d(0:im,0:jm),y_2d(0:im,0:jm))
      call H5ReadSubset(x_2d,im,jm,km,'x',gridfile,kslice=0)
      call H5ReadSubset(y_2d,im,jm,km,'y',gridfile,kslice=0)
      !
      allocate(ro_2d(0:im,0:jm),u_2d(0:im,0:jm), v_2d(0:im,0:jm),      &
                w_2d(0:im,0:jm),p_2d(0:im,0:jm), t_2d(0:im,0:jm)       )
      !
      call h5_read2dfrom3d(ro_2d,im,jm,km,'ro',flowfile,kslice=0)
      call h5_read2dfrom3d( u_2d,im,jm,km,'u1',flowfile,kslice=0)
      call h5_read2dfrom3d( v_2d,im,jm,km,'u2',flowfile,kslice=0)
      call h5_read2dfrom3d( w_2d,im,jm,km,'u3',flowfile,kslice=0)
      call h5_read2dfrom3d( p_2d,im,jm,km, 'p',flowfile,kslice=0)
      call h5_read2dfrom3d( t_2d,im,jm,km, 't',flowfile,kslice=0)
      !
      ! call writeprvbin(outputfile,x_2d,'x',y_2d,'y',ro_2d,'ro',u_2d,'u',   &
      !                                v_2d,'v',p_2d,'p',t_2d,'t',im,jm)
      call tecbin(outputfile,x_2d,'x',y_2d,'y',ro_2d,'ro',u_2d,'u',   &
                                        v_2d,'v',p_2d,'p',t_2d,'t')
    elseif(viewmode=='3d') then
      allocate(x(0:im,0:jm,0:km),y(0:im,0:jm,0:km),z(0:im,0:jm,0:km))
    else
      print*,viewmode
      stop ' !! mode is not defined @ fieldview'
    endif
    !
  end subroutine fieldview
  !+-------------------------------------------------------------------+
  !| The end of the subroutine flowfieldview.                          |
  !+-------------------------------------------------------------------+
  !
  !+-------------------------------------------------------------------+
  !| This subroutine is used to generate a divergence free fluctuation.|
  !+-------------------------------------------------------------------+
  !| Ref: Blaisdell, G. A., Numerical simulation of compressible       |
  !|      homogeneous turbulence, Phd, 1991, Stanford University       |
  !| CHANGE RECORD                                                     |
  !| -------------                                                     |
  !| 26-09-2022: Created by J. Fang @ STFC Daresbury Laboratory        |
  !+-------------------------------------------------------------------+
  subroutine div_free_gen
    !
    use singleton
    use commvar, only : ia,ja,ka,mach
    use hdf5io,   only: h5srite
    !
    ! local data
    integer :: kmi,kmj,kmk,kmax
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! kmi: maximal wavenumber in i direction
    ! kmj: maximal wavenumber in j direction
    ! kmk: maximal wavenumber in k direction
    ! kmax: maximal wavenumber in all direction
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    real(8) :: wn1,wn2,wn3,wn12,wna
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! wn1: modul of wavenumber in i direction
    ! wn2: modul of wavenumber in j direction
    ! wn3: modul of wavenumber in k direction
    ! wn12: wn12=sqrt(wn1**2+wn2**2)
    ! wna: modul of wavenumber in all direction
    ! (k0*1.d0): the wavenumber at maximum given 
    !     spectrum
    ! Ac: the intensity of given spectrum
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    real(8), allocatable, dimension(:,:,:) :: u1tp,u2tp,u3tp,u1,u2,u3
    !
    complex(8), allocatable, dimension(:,:,:) :: u1c,u2c,u3c,u1ct,u2ct,u3ct,u4ct
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Egv: the given initial energy spectrum
    ! u1c: the spectral velocity in k1 direction
    ! u2c: the spectral velocity in k2 direction
    ! u3c: the spectral velocity in k3 direction
    ! uct: the spectrl variable in (1~*2km)
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    real(8) :: Kenergy,Enstropy,ITGscale,LETT,KolmLength,urms,ufmx
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Kenergy: initial volume averaged turbulent 
    !          kinetic energy
    ! Enstropy: initial volume averaged e
    !           nstrophy
    ! ITGscale: initial integral length scale
    ! LETT: initial large-eddy-turnover time
    ! KolmLength: initial Kolmogorov scale
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    integer :: k1,k2,k3,k0,i,j,k
    real(8) :: ran1,ran2,ran3,rn1,rn2,rn3,var1,var2,var3,ISEA
    complex(8) :: vac1,vac2,vac3,vac4,crn1,crn2
    real(8) :: dudi,lambda
    !
    kmi=ia/2
    kmj=ja/2
    kmk=ka/2
    kmax=idnint(sqrt((kmi**2+kmj**2+kmk**2)*1.d0))+1
    !
    allocate(u1c(-kmi:kmi,-kmj:kmj,-kmk:kmk),                        &
             u2c(-kmi:kmi,-kmj:kmj,-kmk:kmk),                        &
             u3c(-kmi:kmi,-kmj:kmj,-kmk:kmk)                         )
    allocate(u1ct(1:ia,1:ja,1:ka),u2ct(1:ia,1:ja,1:ka),              &  
             u3ct(1:ia,1:ja,1:ka) )
    allocate(u1tp(1:ia,1:ja,1:ka),u2tp(1:ia,1:ja,1:ka),              &
             u3tp(1:ia,1:ja,1:ka),u4ct(1:ia,1:ja,1:ka)               )
    !
    ! Give the inital energy spectrum.
    ISEA=1.d0/224.7699d0
    k0=4
    !
    ! Generate the random velocity field according the given energy 
    ! spectrum
    ! Blaisdell, G. A. 1991 took E(k)=Integer(ui*uicoj*dA(k)). 
    ! This program takes E(k)=Integer(0.5*ui*uicoj*dA(k)). 
    ! Therefor, we take the Ek as twice of that from Blaisdell.
    print*,' ** Generate the random velocity field according the given energy spectrum'
    do k1=0,kmi
    do k2=-kmj,kmj
    do k3=-kmk,kmk
      !
      call random_number(ran1)
      call random_number(ran2)
      call random_number(ran3)
      ! ran1,ran2,ran3: random number distributied in (0,1)
      !
      rn1=ran1*2.d0*pi
      rn2=ran2*2.d0*pi
      rn3=ran3*2.d0*pi
      !
      ! Calculate the modul of the wavenumber in each direction
      wn1=real(k1,8)
      wn2=real(k2,8)
      wn3=real(k3,8)
      wn12=sqrt(wn1**2+wn2**2)
      wna=sqrt(wn1**2+wn2**2+wn3**2)
      !
      ! Calculate the initial energy spectral
      if(k1==0 .and. k2==0 .and. k3==0) then
        var1=0.d0
        var2=0.d0
      else
        var1=IniEnergDis(ISEA*2.d0,K0*1.d0,wna)
        var2=sqrt(var1/4.d0/pi/wna**2)
        ! var2=1.d0
      end if
      !
      ! Gererate the velocity spectrum in half-wavenumber space.
      crn1=rn1*(0.d0,1.d0)
      crn2=rn2*(0.d0,1.d0)
      !
      vac1=var2*cdexp(crn1)*dcos(rn3)
      vac2=var2*cdexp(crn2)*dsin(rn3)
      !
      if(k1==0 .and. k2==0 .and. k3==0) then
        u1c(k1,k2,k3)=0.d0
        u2c(k1,k2,k3)=0.d0
        u3c(k1,k2,k3)=0.d0
      elseif(k1==0 .and. k2==0) then
        u1c(k1,k2,k3)=vac1
        u2c(k1,k2,k3)=vac2
        u3c(k1,k2,k3)=0.d0
      else
        u1c(k1,k2,k3)=(vac1*wna*wn2+vac2*wn1*wn3)/(wna*wn12)
        u2c(k1,k2,k3)=(vac2*wn2*wn3-vac1*wna*wn1)/(wna*wn12)
        u3c(k1,k2,k3)=-vac2*wn12/wna
      end if
      !
    end do
    end do
    end do
    !
    print*,' ** Generate the velocity spectrum in another half-wavenumber space '
    ! Generate the velocity spectrum in another half-wavenumber space
    ! by using conjunction relation
    do k1=-kmi,-1
    do k2=-kmj,kmj
    do k3=-kmk,kmk
      u1c(k1,k2,k3)=conjg(u1c(-k1,-k2,-k3))
      u2c(k1,k2,k3)=conjg(u2c(-k1,-k2,-k3))
      u3c(k1,k2,k3)=conjg(u3c(-k1,-k2,-k3))
    end do
    end do
    end do
    ! !
    ! Transform the spectrum from (-N/2+1,N/2) to (1,N) fo rthe 
    ! convenience of using external FFT subroutine
    print*,' ** Transform the spectrum from (-N/2+1,N/2) to (1,N)  '
    !
    do k=1,ka
    do j=1,ja
    do i=1,ia
      if(i<=ia/2+1) then
        k1=i-1
      else
        k1=i-ia-1
      end if
      if(j<=ja/2+1) then
        k2=j-1
      else
        k2=j-ja-1
      end if
      if(k<=ka/2+1) then
        k3=k-1
      else
        k3=k-ka-1
      end if
      !
      u1ct(i,j,k)=u1c(k1,k2,k3)
      u2ct(i,j,k)=u2c(k1,k2,k3)
      u3ct(i,j,k)=u3c(k1,k2,k3)
    end do
    end do
    end do
    ! !
    u1ct=FFT(u1ct,inv=.true.)
    u2ct=FFT(u2ct,inv=.true.)
    u3ct=FFT(u3ct,inv=.true.)
    !
    print*,' ** project to physical space. '
    !
    allocate(u1(0:ia,0:ja,0:ka),u2(0:ia,0:ja,0:ka),u3(0:ia,0:ja,0:ka))
    do k=1,ka
    do j=1,ja
    do i=1,ia
      ! multiply sqrt(NxNyNz) for return standard FFT
      u1(i,j,k)=real(u1ct(i,j,k),8)*sqrt(real(ia*ja*ka,8))
      u2(i,j,k)=real(u2ct(i,j,k),8)*sqrt(real(ia*ja*ka,8))
      u3(i,j,k)=real(u3ct(i,j,k),8)*sqrt(real(ia*ja*ka,8))
      !
    end do
    end do
    end do
    !
    u1(0,1:ja,1:ka)=u1(ia,1:ja,1:ka)
    u2(0,1:ja,1:ka)=u2(ia,1:ja,1:ka)
    u3(0,1:ja,1:ka)=u3(ia,1:ja,1:ka)
    !
    u1(0:ia,0,1:ka)=u1(0:ia,ja,1:ka)
    u2(0:ia,0,1:ka)=u2(0:ia,ja,1:ka)
    u3(0:ia,0,1:ka)=u3(0:ia,ja,1:ka)
    !
    u1(0:ia,0:ja,0)=u1(0:ia,0:ja,ka)
    u2(0:ia,0:ja,0)=u2(0:ia,0:ja,ka)
    u3(0:ia,0:ja,0)=u3(0:ia,0:ja,ka)
    !
    urms=0.d0
    ufmx=0.d0
    Kenergy=0.d0
    do k=1,ka
    do j=1,ja
    do i=1,ia
      Kenergy=Kenergy+0.5d0*(u1(i,j,k)**2+u2(i,j,k)**2+u3(i,j,k)**2)
      urms=urms+u1(i,j,k)**2+u2(i,j,k)**2+u3(i,j,k)**2
      ufmx=max(ufmx,dabs(u1(i,j,k)),dabs(u2(i,j,k)),dabs(u3(i,j,k)))
    end do
    end do
    end do
    urms=sqrt(urms/real(ia*ja*ka,8))
    Kenergy=Kenergy/real(ia*ja*ka,8)
    !
    u1=u1/urms
    u2=u2/urms
    u3=u3/urms
    Kenergy=Kenergy/urms/urms
    urms=urms/urms
    !
    print*,'Kenergy',Kenergy,'urms',urms,'Mat=',urms*Mach
    !
    call h5srite(var=u1,varname='u1',filename='velocity.h5',explicit=.true.,newfile=.true.)
    call h5srite(var=u2,varname='u2',filename='velocity.h5',explicit=.true.)
    call h5srite(var=u3,varname='u3',filename='velocity.h5',explicit=.true.)
    !
    deallocate(u1,u2,u3)
    deallocate(u1c,u2c,u3c)
    deallocate(u1ct,u2ct,u3ct)
    deallocate(u1tp,u2tp,u3tp)
    !
  end subroutine div_free_gen
  !+-------------------------------------------------------------------+
  !| The end of the function div_free_gen.                             |
  !+-------------------------------------------------------------------+
  !!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! This function is used to calcuate the spectral energy at any 
  ! wavenumber.
  ! Ref: S. JAMME, et al. Direct Numerical Simulation of the 
  ! Interaction between a Shock Wave and Various Types of Isotropic 
  ! Turbulence, Flow, Turbulence and Combustion, 2002, 68:227每268.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function IniEnergDis(Ac,k0,wnb)
    !
    real(8) :: k0,Ac,var1,wnb,IniEnergDis
    !
    var1=-2.d0*(wnb/k0)**2
    IniEnergDis=Ac*wnb**4*dexp(var1)
    !IniEnergDis=Ac*wnb**(-5.d0/3.d0)
    !
    return
    !
  end function IniEnergDis
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! End of the function Ek.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  !
end module pp
!+---------------------------------------------------------------------+
!| The end of the module pp                                            |
!+---------------------------------------------------------------------+